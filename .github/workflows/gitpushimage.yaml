name: Build, push, and bump sparkreports image

on:
  push:
    branches: [ main ]

permissions:
  contents: write

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  KUBE_VERSION: "1.29.0"

jobs:
  build_push_docker_image:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.bump.outputs.version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bump version from version.txt
        id: bump
        run: |
          if [ ! -f version.txt ]; then echo 0 > version.txt; fi
          CUR=$(tr -d '\r' < version.txt)
          NEW=$((CUR + 1))
          echo "$NEW" > version.txt
          echo "version=$NEW" >> "$GITHUB_OUTPUT"
          echo "VERSION=$NEW" >> "$GITHUB_ENV"
          echo "Bumped version: $CUR -> $NEW"

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Build JAR with Maven
        run: mvn -q -B clean package --file pom.xml

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            monicamarshall/sparkreports:${{ env.VERSION }}
            monicamarshall/sparkreports:latest

      - name: Commit & push version bump safely
        run: |
          git config user.email "${{ secrets.GIT_EMAIL }}"
          git config user.name  "${{ secrets.GIT_USERNAME }}"
          git checkout "${GITHUB_REF_NAME}"
          git add version.txt
          git commit -m "chore: bump version to $VERSION" || echo "No changes to commit"
          git fetch origin
          git pull --rebase --autostash origin "${GITHUB_REF_NAME}"
          git push origin "${GITHUB_REF_NAME}"

  update_k8s_yaml:
    runs-on: ubuntu-latest
    needs: build_push_docker_image

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.email "${{ secrets.GIT_EMAIL }}"
          git config user.name  "${{ secrets.GIT_USERNAME }}"

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Install kubeconform (offline validator)
        run: |
          curl -L -o kubeconform.tar.gz https://github.com/yannh/kubeconform/releases/download/v0.6.7/kubeconform-linux-amd64.tar.gz
          tar -xzf kubeconform.tar.gz kubeconform
          sudo mv kubeconform /usr/local/bin/

      - name: Update deployment.yaml image tag (safe) and validate
        env:
          VERSION: ${{ needs.build_push_docker_image.outputs.version }}
          KUBE_VERSION: ${{ env.KUBE_VERSION }}
        run: |
          set -euo pipefail
          yq --version
          kubeconform -v

          # Validate before change (ignore missing CRD schemas)
          kubeconform -strict -summary -ignore-missing-schemas -kubernetes-version "${KUBE_VERSION}" deployment.yaml

          # Update ONLY the container named sparkreports-container in the named Deployment
          yq -i '
            (. | select(.kind == "Deployment" and .metadata.name == "spark-reports-deployment")
               | .spec.template.spec.containers[] 
               | select(.name == "sparkreports-container")
               | .image) = "monicamarshall/sparkreports:" + env(VERSION)
          ' deployment.yaml

          # Validate after change
          kubeconform -strict -summary -ignore-missing-schemas -kubernetes-version "${KUBE_VERSION}" deployment.yaml

          git add deployment.yaml
          git commit -m "chore: deploy image tag ${VERSION}" || echo "No changes to commit"
          git fetch origin
          git pull --rebase --autostash origin "${GITHUB_REF_NAME}"
          git push origin "${GITHUB_REF_NAME}"

  verify_deploy:
    runs-on: ubuntu-latest
    needs: [update_k8s_yaml, build_push_docker_image]
    env:
      AWS_REGION: us-east-2
      EKS_CLUSTER: spark-cluster
      NAMESPACE: spark-reports
      DEPLOYMENT: spark-reports-deployment
      CONTAINER_NAME: sparkreports-container
      EXPECTED_TAG: ${{ needs.build_push_docker_image.outputs.version }}

    steps:
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl
          kubectl version --client=true

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig for EKS
        run: aws eks update-kubeconfig --name "${EKS_CLUSTER}" --region "${AWS_REGION}"

      # Ensure the cluster is actually updated to the new image tag, regardless of GitOps sync timing
      - name: Set image on Deployment to expected tag
        run: |
          kubectl set image "deployment/${DEPLOYMENT}" "${CONTAINER_NAME}=monicamarshall/sparkreports:${EXPECTED_TAG}" -n "${NAMESPACE}" --record
          kubectl annotate deployment "${DEPLOYMENT}" kubernetes.io/change-cause="CI set image to :${EXPECTED_TAG}" -n "${NAMESPACE}" --overwrite

      - name: Wait for rollout to complete
        run: kubectl rollout status "deployment/${DEPLOYMENT}" -n "${NAMESPACE}" --timeout=10m

      - name: Verify image tag matches expected
        run: |
          ACTUAL_IMAGE=$(kubectl get deployment "${DEPLOYMENT}" -n "${NAMESPACE}"             -o jsonpath='{.spec.template.spec.containers[?(@.name=="'"${CONTAINER_NAME}"'")].image}')
          echo "Cluster is running image: ${ACTUAL_IMAGE}"
          if ! echo "${ACTUAL_IMAGE}" | grep -q "monicamarshall/sparkreports:${EXPECTED_TAG}$"; then
            echo "ERROR: Expected tag :${EXPECTED_TAG} but found ${ACTUAL_IMAGE}"
            exit 1
          fi
          echo "OK: Image tag matches :${EXPECTED_TAG}"
