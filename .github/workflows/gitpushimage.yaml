name: Build, push, and bump sparkreports image

on:
  push:
    branches: [ main ]

permissions:
  contents: write

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build_push_docker_image:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.bump.outputs.version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # needed for rebase & pushing

      - name: Bump version from version.txt
        id: bump
        run: |
          if [ ! -f version.txt ]; then echo 0 > version.txt; fi
          CUR=$(tr -d '\r' < version.txt)
          NEW=$((CUR + 1))
          echo "$NEW" > version.txt
          echo "version=$NEW" >> "$GITHUB_OUTPUT"
          echo "VERSION=$NEW" >> "$GITHUB_ENV"
          echo "Bumped version: $CUR -> $NEW"

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Build JAR with Maven
        run: mvn -q -B clean package --file pom.xml

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            monicamarshall/sparkreports:${{ env.VERSION }}
            monicamarshall/sparkreports:latest

      - name: Commit & push version bump safely
        run: |
          git config user.email "${{ secrets.GIT_EMAIL }}"
          git config user.name  "${{ secrets.GIT_USERNAME }}"

          # Make sure weâ€™re on the workflow branch
          git checkout "${GITHUB_REF_NAME}"

          # Stage & commit local edits FIRST
          git add version.txt
          git commit -m "chore: bump version to $VERSION" || echo "No changes to commit"

          # Rebase on remote to avoid non-fast-forward rejects
          git fetch origin
          git pull --rebase --autostash origin "${GITHUB_REF_NAME}"

          # Push the rebased commit
          git push origin "${GITHUB_REF_NAME}"

  update_k8s_yaml:
    runs-on: ubuntu-latest
    needs: build_push_docker_image

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.email "${{ secrets.GIT_EMAIL }}"
          git config user.name  "${{ secrets.GIT_USERNAME }}"

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Install kubeconform (offline validator)
        run: |
          curl -L -o kubeconform.tar.gz https://github.com/yannh/kubeconform/releases/download/v0.6.7/kubeconform-linux-amd64.tar.gz
          tar -xzf kubeconform.tar.gz kubeconform
          sudo mv kubeconform /usr/local/bin/

      - name: Update deployment.yaml image tag (safe) and validate
        env:
          VERSION: ${{ needs.build_push_docker_image.outputs.version }}
        run: |
          set -euo pipefail
          yq --version
          kubeconform -v
          # validate offline; ignore unknown CRDs if any, but fail on real schema errors
          kubeconform -strict -summary -ignore-missing-schemas -kubernetes-version 1.33.0 deployment.yaml

          # Update ONLY the Deployment doc named spark-reports-deployment,
          # and ONLY the container named sparkreports-container
          yq -i '
            select(.kind == "Deployment" and .metadata.name == "spark-reports-deployment")
            | (.spec.template.spec.containers[]
              | select(.name == "sparkreports-container")
              | .image) = "monicamarshall/sparkreports:" + env(VERSION)
          ' deployment.yaml

          #Offline schema validation (no cluster/kubeconfig needed)
          kubeconform -strict -summary -kubernetes-version 1.33.0 deployment.yaml

          # Stage & commit local edits FIRST
          git add deployment.yaml
          git commit -m "chore: deploy image tag ${VERSION}" || echo "No changes to commit"

          # Rebase onto remote to avoid rejects
          git fetch origin
          git pull --rebase --autostash origin "${GITHUB_REF_NAME}"

          # Push the rebased commit
          git push origin "${GITHUB_REF_NAME}"


  verify_deploy:
    runs-on: ubuntu-latest
    needs: update_k8s_yaml
    env:
      AWS_REGION: us-east-2
      EKS_CLUSTER: spark-cluster
      NAMESPACE: spark-reports
      DEPLOYMENT: spark-reports-deployment
      CONTAINER_NAME: sparkreports-container
      EXPECTED_TAG: ${{ needs.build_push_docker_image.outputs.version }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Who am I?  # optional debug
        run: aws sts get-caller-identity

      - name: Update kubeconfig for EKS
        run: aws eks update-kubeconfig --name "${EKS_CLUSTER}" --region "${AWS_REGION}"

      - name: Wait for rollout to complete
        run: kubectl rollout status "deployment/${DEPLOYMENT}" -n "${NAMESPACE}" --timeout=5m
      - name: Ensure EXPECTED_TAG is set    # <-- new block goes here
        run: |
          echo "EXPECTED_TAG='${EXPECTED_TAG}'"
          if [ -z "${EXPECTED_TAG}" ]; then
            echo "EXPECTED_TAG is empty; check job outputs/needs."
            exit 1
          fi

      - name: Verify image tag matches expected
        run: |
          ACTUAL_IMAGE=$(kubectl get deployment "${DEPLOYMENT}" -n "${NAMESPACE}" \
            -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "Cluster is running image: ${ACTUAL_IMAGE}"
          if ! echo "${ACTUAL_IMAGE}" | grep -q "monicamarshall/sparkreports:${EXPECTED_TAG}$"; then
            echo "ERROR: Expected tag :${EXPECTED_TAG} but found ${ACTUAL_IMAGE}"
            exit 1
          fi
          echo "OK: Image tag matches :${EXPECTED_TAG}"

